#% text_encoding = iso8859_1
_package mt

_pragma(classify_level=basic, topic=type_dumper)
## Method definition.
## @slot {sw:char16_vector} type_n
## @slot {sw:char16_vector} m_name
## @slot {sw:simple_vector<E=sw:char16_vector>} mods
## @slot {sw:simple_vector<E=mt:parameter_definition>} params
## @slot {mt:parameter_definition|sw:unset} a_param
## @slot {sw:simple_vector<E=sw:char16_vector>} ret
## @slot {sw:simple_vector<E=sw:char16_vector>} loop
## @slot {sw:char16_vector|sw:unset} src
## @slot {sw:char16_vector|sw:unset} doc
## @slot {sw:char16_vector|sw:unset} hash
## @slot {sw:char16_vector|sw:unset} mod_n
## @slot {sw:simple_vector<E=sw:char16_vector>} top
def_slotted_exemplar(
	:method_definition,
	{
		{:type_n, _unset, :readable, :public},
		{:m_name, _unset, :readable, :public},
		{:mods, _unset, :readable, :public},
		{:params, _unset, :readable, :public},
		{:a_param, _unset, :readable, :public},
		{:ret, _unset, :readable, :public},
		{:loop, _unset, :readable, :public},
		{:src, _unset, :readable, :public},
		{:doc, _unset, :readable, :public},
		{:hash, _unset, :readable, :public},
		{:mod_n, _unset, :readable, :public},
		{:top, _unset, :readable, :public}
	},
	{@mt:definition})
$

_pragma(classify_level=basic, topic=type_dumper, usage=external)
## @return {sw:integer}
method_definition.define_shared_constant(
	:instruction_type,
	6,
	:public)
$

_pragma(classify_level=basic, topic=type_dumper)
_method method_definition.new(
	type_name,
	method_name,
	modifiers,
	parameters,
	assignment_parameter,
	return_types,
	loop_types,
	source_file,
	doc,
	hash,
	module_name,
	topics)
	## Constructor.
	## @param {sw:char16_vector} type_name
	## @param {sw:char16_vector} method_name
	## @param {sw:simple_vector<E=sw:char16_vector>} modifiers
	## @param {sw:simple_vector<E=mt:parameter_definition>} parameters
	## @param {mt:parameter_definition|sw:unset} assignment_parameter
	## @param {sw:simple_vector<E=sw:char16_vector>} return_types
	## @param {sw:simple_vector<E=sw:char16_vector>} loop_types
	## @param {sw:char16_vector|sw:unset} source_file
	## @param {sw:char16_vector|sw:unset} doc
	## @param {sw:char16_vector|sw:unset} hash
	## @param {sw:char16_vector|sw:unset} module_name
	## @param {sw:simple_vector<E=sw:char16_vector>} topics
	## @return {_self}
	_return _clone.init(
		type_name,
		method_name,
		modifiers,
		parameters,
		assignment_parameter,
		return_types,
		loop_types,
		source_file,
		doc,
		hash,
		module_name,
		topics)
_endmethod
$

_pragma(classify_level=basic, topic=type_dumper)
_private _method method_definition.init(
	type_name,
	method_name,
	modifiers,
	parameters,
	assignment_parameter,
	return_types,
	loop_types,
	source_file,
	doc,
	hash,
	module_name,
	topics)
	## Initializer.
	## @param {sw:char16_vector} type_name
	## @param {sw:char16_vector} method_name
	## @param {sw:simple_vector<E=sw:char16_vector>} modifiers
	## @param {sw:simple_vector<E=mt:parameter_definition>} parameters
	## @param {mt:parameter_definition|sw:unset} assignment_parameter
	## @param {sw:simple_vector<E=sw:char16_vector>} return_types
	## @param {sw:simple_vector<E=sw:char16_vector>} loop_types
	## @param {sw:char16_vector|sw:unset} source_file
	## @param {sw:char16_vector|sw:unset} doc
	## @param {sw:char16_vector|sw:unset} hash
	## @param {sw:char16_vector|sw:unset} module_name
	## @param {sw:simple_vector<E=sw:char16_vector>} topics
	## @return {_self}
	.type_n << type_name
	.m_name << method_name
	.mods << modifiers
	.params << parameters
	.a_param << assignment_parameter
	.ret << return_types
	.loop << loop_types
	.src << source_file
	.doc << doc
	.hash << hash
	.mod_n << module_name
	.top << topics
	_return _self
_endmethod
$

_pragma(classify_level=basic, topic=type_dumper)
_private _method method_definition.init_from_json(instruction)
	## Initialize self from JSON.
	## @param {sw:equality_hash_table} instruction
	## @return {_self}
	_super.init_from_json(instruction)

	# Fix parameters.
	.params << .params.map(
		_proc(param)
			_return parameter_definition.sys!perform(:|new_from_json()|, param)
		_endproc)

	# Fix assignment_parameter.
	_if .a_param _isnt _unset
	_then
		.a_param << parameter_definition.sys!perform(:|new_from_json()|, .a_param)
	_endif

	_return _self
_endmethod
$

_pragma(classify_level=basic, topic=type_dumper)
_method method_definition.new_from(package, name, method)
	## Construct self from.
	## @param {sw:package} package
	## @param {sw:symbol} name
	## @param {sw:method} method
	## @return {_self}
	_local type_name << _self.name_from_type(package, name)
	_local modifiers << rope.new()
	_if method.abstract?
	_then
		modifiers.add_last("abstract")
	_endif
	_if method.private?
	_then
		modifiers.add_last("private")
	_endif
	_if method.iter?
	_then
		modifiers.add_last("iter")
	_endif

	_local parameter_definitions << parameter_definition.new_from(method.name, method.value)
	_local assignment_parameter << _unset
	_if method.name.matches?(:|*<<|)
	_then
		assignment_parameter << parameter_definitions[1]
		parameter_definitions << parameter_definitions.subseq(2)
	_endif
	_local return_types <<
		_if method.shared_constant?
		_then
			_local value << method.invokable.invoke()
			>> {_self.name_from_object(value)}
		_else
			>> _self.undefined_result
		_endif
	_local loop_types <<
		_if method.iter?
		_then
			>> _self.undefined_result
		_else
			>> {}
		_endif
	_local source_file <<
		_if _not method.slot_accessor?
		_then
			>> _try
				   >> _self.normalized_source_file(method.source_file)
			   _when error
				   # pass
			   _endtry
		_endif
	_local doc << method_finder.get_method_comment(method.name, type_name)
	_local type << method.owner.meta_at(:exemplar)
	_local hash <<
		_if _not method.slot_accessor? _andif
		    _not method.shared_constant? _andif
		    _not method.shared_variable?
		_then
			>> _try
				   >> sw!method_hash(type, method.name)
			   _when error
				   # pass
			   _endtry
		_endif
	_local module_name <<
		_try
			>> method.source_module.name
		_when error
			>> _unset
		_endtry
	_local topics <<
		_try
			>> method_finder.get_method_topics(method.name, type_name)
		_when error
			>> {}
		_endtry
	_return _self.new(
		type_name,
		method.name,
		modifiers,
		parameter_definitions,
		assignment_parameter,
		return_types,
		loop_types,
		source_file,
		doc,
		hash,
		module_name,
		topics)
_endmethod
$

_pragma(condition_definition=basic, topic=type_dumper)
_method method_definition.sort_value
	## Sort value.
	## @return {sw:char16_vector}
	_return .type_n + "." + .m_name
_endmethod
$

_pragma(classify_level=basic, topic=type_dumper)
_method method_definition.equals?(other)
	## Equals?
	## @param {mt:method_definition} other
	## @return {sw:false}
	_return _self.type_n = other.type_n _andif
		_self.m_name = other.m_name _andif
		_self.mods.eq?(other.mods) _andif
		_self.params.eq?(other.params) _andif
		_self.a_param = other.a_param _andif
		_self.ret.eq?(other.ret) _andif
		_self.loop.eq?(other.loop) _andif
		_self.src = other.src _andif
		_self.doc = other.doc _andif
		_self.hash = other.hash _andif
		_self.mod_n = other.mod_n _andif
		_self.top.eq?(other.top)
_endmethod
$

_pragma(classify_level=basic, topic=type_dumper)
_method method_definition.equals_disregarding_typing?(other)
	## Equals disregarding typing?
	## @param {mt:method_definition} other
	## @return {sw:false}
	_return _self.type_n = other.type_n _andif
		_self.m_name = other.m_name _andif
		_self.mods.eq?(other.mods) _andif
		_self.params.eq?(other.params, :|equals_disregarding_typing?()|) _andif (
			_self.a_param _is _unset _andif other.a_param _is _unset _orif
			_self.a_param.equals_disregarding_typing?(other.a_param)) _andif
		_self.src = other.src _andif
		_self.doc = other.doc _andif
		_self.hash = other.hash _andif
		_self.mod_n = other.mod_n _andif
		_self.top.eq?(other.top)
_endmethod
$

define_binary_operator_case(
	:|cf|, method_definition, method_definition,
	_proc(definition_a, definition_b)
		## @param {mt:method_definition} definition_a
		## @param {mt:method_definition} definition_b
		## @return {sw:false|sw:maybe}
		_return definition_a.sort_value _cf definition_b.sort_value
	_endproc)
$

define_binary_operator_case(
	:|=|, method_definition, method_definition,
	_proc(definition_a, definition_b)
		## @param {mt:method_definition} definition_a
		## @param {mt:method_definition} definition_b
		## @return {sw:false|sw:maybe}
		_return definition_a.equals?(definition_b)
	_endproc)
$

method_definition.define_show_attributes(
	:type_n,
	:m_name)
$
